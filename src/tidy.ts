
import {
    Diagnostic, DiagnosticSeverity, TextDocument, WorkspaceFolder, Connection
} from 'vscode-languageserver';
import { spawn } from 'child_process';
import { safeLoad } from 'js-yaml';
import Uri from 'vscode-uri';
import * as path from 'path';
import * as fs from 'fs';

// Build to run clang-tidy on the given textDocument.
//
// Arguments are constructed from the following parts:
// - The textDocument file path
// - '--export-fixes=-' to convert output to YAML which can be parsed into the required VSCode Diagnostic objects.
// - A set of '-extra-arg=-isystem' paths derived from configuration.systemIncludePath (user settings)
// - A set of '-extra-arg-before' derived from configuration.extraCompilerArgs (user settings)
// - Additional arguments from configuration.args (user settings)
// - Additional include directories and compile standards derived from c_cpp_properties.json for the current workspace.
// - A build path ('-p') derived from all compile_commands.json found in the current workspace. See getBuildPathOption()
//     - Only added if '-p' is not already present.
//
// Additionally all of the string "${workspaceFolder}" in arguments are replaced with the current workspace folder.
//
// Automatic generation of the '-p' argument is intended to deal with workspace which support compile_commands.json and
// may supersede many explicit arguments. For example, compile_commands.json will contain the precise compile arguments
// for a file in a CMake based workspace. The '-p' contain all the compile_commands.json in the current workspace in
// order to cope with multi-project meta-build workspaces such as those generated by catkin_tools or colcon.
function buildDiagnosticArgs(textDocument: TextDocument, configuration: Configuration,
                             workspaceFolders: WorkspaceFolder[], compileCommandsJson: string | null = null): string[] {
    const args: string[] = [Uri.parse(textDocument.uri).fsPath, '--export-fixes=-'];

    if (!compileCommandsJson) {
        if (compileCommandsJson && compileCommandsJson.length === 0) {
            compileCommandsJson = null;
        }

        if (configuration.headerFilter) {
            args.push('-header-filter=' + configuration.headerFilter);
        }

        configuration.systemIncludePath.forEach(path => {
            const arg = '-extra-arg=-isystem' + path;
            args.push(arg);
        });

        configuration.extraCompilerArgs.forEach(arg => {
            args.push('-extra-arg-before=' + arg);
        });

        configuration.args.forEach(arg => {
            args.push(arg);
        });

        let cppToolsConfigs: CppToolsConfigs | null = null;
        if (workspaceFolders) {
            cppToolsConfigs = readConfigFromCppTools(workspaceFolders);
        }

        if (cppToolsConfigs && !compileCommandsJson) {
            const { cppToolsIncludePaths, cStandard, cppStandard } = cppToolsConfigs;
            if (textDocument.languageId === 'c') {
                args.push('-extra-arg-before=-xc');
                if (cStandard) {
                    args.push('-extra-arg-before=-std=' + cStandard);
                }
            }

            if (textDocument.languageId === 'cpp') {
                args.push('-extra-arg-before=-xc++');
                if (cppStandard) {
                    args.push('-extra-arg-before=-std=' + cppStandard);
                }
            }

            cppToolsIncludePaths.forEach(path => {
                const arg = '-extra-arg=-I' + path;
                args.push(arg);
            });
        }
    } else {
        args.push('-config=');
        args.push('-p=' + compileCommandsJson);
    }

    // Replace ${workspaceFolder} in arguments. Seem to be a number of issues open regarding
    // support for this in the VSCode API, but I can't find a solution.
    if (workspaceFolders) {
        const workspaceFolder = Uri.parse(workspaceFolders[0].uri).fsPath;
        for (var i = 0; i < args.length; ++i) {
            args[i] = args[i].replace("${workspaceFolder}", workspaceFolder);
        }
    }

    return args;
}

function addCompileCommandsJson(compileCommandsJson: string[], dir: string) {
    const files = fs.readdirSync(dir);

    for (var i = 0; i < files.length; ++i) {
        const filePath = path.join(dir, files[i]);
        const stats = fs.lstatSync(filePath);
        if (stats) {
            if (stats.isDirectory()) {
                addCompileCommandsJson(compileCommandsJson, filePath);
            }
            else if (stats.isFile() || stats.isSymbolicLink()) {
                if (files[i] === 'compile_commands.json') {
                    if (compileCommandsJson.indexOf(filePath) === -1) {
                        compileCommandsJson.push(filePath);
                    }
                }
            }
        }
    }
}

function findCompileCommands(workspaceFolders: WorkspaceFolder[]): string[] {
    const commandFiles: string[] = [];
    for (var i = 0; i < workspaceFolders.length; ++i) {
        const workspaceFolder = workspaceFolders[i];
        try {
            const uri = Uri.parse(workspaceFolder.uri);
            addCompileCommandsJson(commandFiles, uri.path);
        } catch (exception) {
            // Most likely failed to parse Uri
            console.error(exception);
        }
    }

    return commandFiles;
}

function runTidyProcess(executablePath: string, argSets: string[][],
        textDocument: TextDocument,
        onParsed: (doc: TextDocument, diagnostics: { [id: string]: Diagnostic[] }, diagnosticsCount: number) => void) {

    if (argSets.length === 0) {
        return;
    }

    const args = argSets[0];

    let decoded = '';
    let diagnosticsCount: number = 0;

    // Dictionary of collated diagnostics keyed on absolute file name. This supports source files generating
    // diagnostics for header files.
    const diagnostics: { [id: string]: Diagnostic[]; } = {};

    // Dictionary of text documents used to resolve character offsets into ranges.
    // We need to support the textDocument and additional included files (e.g., header files) and use it to resolve
    // file level character offsets into line/character offsets used by VSCode.
    // Keyed on absolute file name.
    const docs: { [id: string]: TextDocument } = {};

    // Immediately add entries for the textDocument.
    diagnostics[Uri.parse(textDocument.uri).fsPath] = [];
    docs[Uri.parse(textDocument.uri).fsPath] = textDocument;

    // Spawn the clang-tidy process.
    // console.warn(executablePath + ' ' + args);
    const childProcess = spawn(executablePath, args);

    childProcess.on('error', console.error);
    if (childProcess.pid) {
        childProcess.stdout.on('data', (data) => {
            decoded += data;
        });

        childProcess.stdout.on('end', () => {
            if (decoded.length === 0) {
                // No output: failed to run with these args. Try the next.
                if (argSets.length > 1) {
                    runTidyProcess(executablePath, argSets.slice(1), textDocument, onParsed);
                }
                return;
            }

            // console.warn('succeeded');

            const match = decoded.match(/(^\-\-\-(.*\n)*\.\.\.$)/gm);
            if (match && match[0]) {
                const yaml = match[0];
                const parsed = safeLoad(yaml) as ClangTidyResult;
                parsed.Diagnostics.forEach((element: ClangTidyDiagnostic) => {
                    const name: string = element.DiagnosticName;
                    const severity = name.endsWith('error') ?
                        DiagnosticSeverity.Error : DiagnosticSeverity.Warning;
                    const message: string = `${element.Message} (${name})`;

                    // Helper function to ensure absolute paths and required registrations are made.
                    function fixPath(filePath: string): string {
                        if (filePath && !path.isAbsolute(filePath)) {
                            filePath = path.resolve(path.dirname(Uri.parse(textDocument.uri).fsPath),
                                filePath);
                        }

                        if (!(filePath in diagnostics)) {
                            diagnostics[filePath] = [];
                        }

                        // Resolve replacement.FileOffset and replacement.Length into a range.
                        let doc: TextDocument | undefined = undefined;

                        // Resolve the document.
                        if (!(filePath in docs)) {
                            // Unresolved. We'll create a new TextDocument reference loading the content.
                            // This is potentially inefficient, and it would be nice to see if we can leverage
                            // VSCode to manage this.
                            if (fs.existsSync(filePath)) {
                                doc = TextDocument.create("file://" + filePath,
                                    textDocument.languageId, 0,
                                    fs.readFileSync(filePath).toString());
                                docs[filePath] = doc;
                            }
                        }

                        return filePath;
                    }

                    // Create a dictionary of diagnostics ensuring we use absolute paths to handle errors from
                    // headers.
                    const clangTidySourceName: string = 'Clang Tidy';

                    // Ensure an absolute path for the main clang-tidy element.
                    element.FilePath = fixPath(element.FilePath);

                    // Iterate the replacements to:
                    // - Ensure absolute paths.
                    // - Resolve clang's character offset and length to a line and character range.
                    if (element.Replacements) {
                        for (const replacement of element.Replacements) {
                            // Ensure replacement FilePath entries use absolute paths.
                            replacement.FilePath = fixPath(element.FilePath);

                            // Create a diagnostic for the replacement. The context of each replacement may be a
                            // different file from the element's FilePath.
                            let doc: TextDocument;
                            if (replacement.FilePath in docs) {
                                doc = docs[replacement.FilePath];

                                //replacement.Offset is byte offset, not the character offset
                                //when your source file contains some symbol which takes more than one byte
                                //to encode, it will cause error.
                                const doc_buff = Buffer.from(doc.getText());
                                const character_offset = doc_buff.toString('utf-8', 0, replacement.Offset).length;

                                replacement.Range = {
                                    start: doc.positionAt(character_offset),
                                    end: doc.positionAt(character_offset + replacement.Length)
                                };
                            }
                        }
                    }
                    // Create a VSCode Diagnostic. Use the original textDocument if we fail to resolve the document
                    // path. This ensures the user gets feedback.
                    const doc = element.FilePath in docs ? docs[element.FilePath] : textDocument;
                    element.Range = {
                        start: doc.positionAt(element.FileOffset),
                        end: doc.positionAt(element.FileOffset)
                    };

                    const diagnostic: Diagnostic = Diagnostic.create(element.Range, message, severity,
                        element.Replacements && JSON.stringify(element.Replacements), clangTidySourceName);

                    diagnostics[element.FilePath].push(diagnostic);
                    ++diagnosticsCount;

                });
            }

            onParsed(textDocument, diagnostics, diagnosticsCount);
        });
    }
}

// Invoke clang-tidy and transform it issues into a file/Diagnostics map.
//
// This invoke clang-tidy with the configured arguments and parses the results into vscode-languageserver.Diagnostic
// objects. Each diagnostic contains the set of replacements clang-tidy recommends to address the issue.
// The original clang-tidy recommendations are stored in the Diagnostic.code member in JSON string format. This can be
// parsed into a ClangTidyDiagnostic.
//
// The ClangTidyDiagnostic and associated ClangTidyReplacement objects are extended to each contain a Range member.
// This member is an alias for the FileOffset/Offset + Length members into a vscode-languageserver.Range value. This
// better supports integration with vscode we have sufficient data to more easily resolve the range value here rather
// than later.
//
// textDocument: The TextDocument to lint using clang-tidyDiagnostic
// configuration: Details of the clang-tidy-linter extension configuration; i.e., how to invoke clang-tidy.
// workspaceFolders: array of folders in the current workspace.
// compileCommandsJson: array of compile_commands.json files found in the current workspace.
//      Used to build -p option (build path).
// onParsed: Callback to invoke once the diagnostics are generateDiagnostics. The argument holds a dictionary of
//       results. These are keyed on absolute file path (not URI) and the array of associated Diagnostics for that file.
export function generateDiagnostics(
    connection: Connection,
    textDocument: TextDocument, configuration: Configuration,
    workspaceFolders: WorkspaceFolder[],
    onParsed: (doc: TextDocument, diagnostics: { [id: string]: Diagnostic[] },
        diagnosticsCount: number) => void) {

    const argSets: string[][] = [];

    // Try running with the compile commands first.
    if (configuration.automaticCompileCommands) {
        const compileCommandsSet = findCompileCommands(workspaceFolders);
        for (var i = 0; i < compileCommandsSet.length; ++i) {
            // Build arguments.
            argSets.push(buildDiagnosticArgs(textDocument, configuration, workspaceFolders, compileCommandsSet[i]));
        }
    }

    // Add fallback arguments.
    argSets.push(buildDiagnosticArgs(textDocument, configuration, workspaceFolders));

    // Now try each of the arguments. We exit as soon as we don't get a result 'Skipping...'
    runTidyProcess(configuration.executable, argSets, textDocument, onParsed);
}

function readConfigFromCppTools(workspaceFolders: WorkspaceFolder[]): CppToolsConfigs {
    const cppToolsIncludePaths: string[] = [];
    let cStandard: string = '';
    let cppStandard: string = '';

    workspaceFolders.forEach(folder => {
        const config = path.join(Uri.parse(folder.uri).fsPath, '.vscode/c_cpp_properties.json');
        if (fs.existsSync(config)) {
            const content = fs.readFileSync(config, { encoding: 'utf8' });
            const configJson = JSON.parse(content);
            if (configJson.configurations) {
                configJson.configurations.forEach((config: any) => {
                    if (config.includePath) {
                        config.includePath.forEach((path: string) => {
                            cppToolsIncludePaths.push(path.replace('${workspaceFolder}', '.'));
                        });
                    }
                    cStandard = config.cStandard;
                    cppStandard = config.cppStandard;
                });
            }
        }
    });

    return {
        cppToolsIncludePaths, cStandard, cppStandard
    };
}